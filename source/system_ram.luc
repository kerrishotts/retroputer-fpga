module system_ram(
    input clk,  // clock
    input rst,  // reset
    
    input wr_addr[19],
    input wr_data[8],
    input wr_valid,
    output wr_ready,
    
    input rd_addr[19],
    input rd_cmd_valid,
    output rd_ready,
    output rd_data[8],
    output rd_data_valid,
    
    input<Memory.out> mem_out,
    output<Memory.in> mem_in
    
  ) {

  .clk(clk), .rst(rst) {
    fsm state = { IDLE, WRITE_CMD, READ_CMD, READ_WAIT };
    dff addr[28];
  }
  
  always {
  
    mem_in.en = 0;
    mem_in.cmd = 3bx;
    mem_in.addr = addr.q;
    mem_in.wr_en = 0;
    mem_in.wr_data = 16x{wr_data};
    mem_in.wr_mask = 16b1111111111111111;
    mem_in.wr_mask[ wr_addr[3:0] ] = 8b0;
    
    wr_ready = state.q == state.IDLE;
    rd_ready = state.q == state.IDLE;
    rd_data = mem_out.rd_data[ addr.q[3:0]*8 +:8 ];
    rd_data_valid = mem_out.rd_valid;
    
    case (state.q) {
      state.IDLE: 
        if (wr_valid) {
          mem_in.wr_en = 1;
          addr.d = c{6b0, wr_addr, 3b0};
          if (mem_out.wr_rdy)
            state.d = state.WRITE_CMD;
        }
        if (rd_cmd_valid) {
          addr.d = c{6b0, rd_addr, 3b0};
          state.d = state.READ_CMD;
        }
      state.WRITE_CMD:
        mem_in.en = 1;
        mem_in.cmd = 0; // write;
        if (mem_out.rdy)
          state.d = state.IDLE;
      state.READ_CMD:
        mem_in.en = 1;
        mem_in.cmd = 1; // read;
        if (mem_out.rdy) 
          state.d = state.READ_WAIT;
      state.READ_WAIT: 
        if (mem_out.rd_valid)
          state.d = state.IDLE;
    
    
  }
}
