module system_ram(
    input clk,  // clock
    input rst,  // reset
    
    input wr_addr[19],
    input wr_data[8],
    input wr_valid,
    output wr_ready,
    
    input rd_addr[19],
    input rd_cmd_valid,
    output rd_ready,
    output rd_data[8],
    output rd_data_valid,
    
    input<Memory.out> mem_out,
    output<Memory.in> mem_in
    
  ) {

  .clk(clk), .rst(rst) {
    fsm state = { IDLE, WRITE_CMD, READ_CMD, READ_WAIT, READ_VALID };
    dff addr[28];
    dff orig_rd_addr[19];
    dff read_data[8];
  }
  
  sig word[16];
  
  always {
  
    mem_in.en = 0;
    mem_in.cmd = 3bx;
    mem_in.addr = addr.q;
    mem_in.wr_en = 0;
    mem_in.wr_data = 8x{c{wr_data, 8b0}};
    mem_in.wr_mask = 128hFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
    mem_in.wr_mask[ wr_addr[2:0] * 2 +:2 ] = 2b0;
    
    wr_ready = state.q == state.IDLE;
    rd_ready = state.q == state.IDLE;
    
    rd_data = 8bx; // word[15:8];
    rd_data_valid = 0; // mem_out.rd_valid;
    
    case (state.q) {
      state.IDLE: 
        if (wr_valid) {
          mem_in.wr_en = 1;
          addr.d = c{9b0, wr_addr[18:3], 3b0};
          if (mem_out.wr_rdy)
            state.d = state.WRITE_CMD;
        }
        if (rd_cmd_valid) {
          addr.d = c{9b0, rd_addr[18:3], 3b0};
          orig_rd_addr.d = rd_addr;
          state.d = state.READ_CMD;
        }
      state.WRITE_CMD:
        mem_in.en = 1;
        mem_in.cmd = 0; // write;
        if (mem_out.rdy)
          state.d = state.IDLE;
      state.READ_CMD:
        mem_in.en = 1;
        mem_in.cmd = 1; // read;
        if (mem_out.rdy) 
          state.d = state.READ_WAIT;
      state.READ_WAIT: 
        if (mem_out.rd_valid) {
          word = mem_out.rd_data[ orig_rd_addr.q[2:0]*16 +:16 ];
          read_data.d = word[15:8];
          state.d = state.READ_VALID;
        }
      state.READ_VALID:
        state.d = state.IDLE;
        rd_data = read_data.q;
        rd_data_valid = 1;
  }
}
