global Reg {
  const A  = 4d0;
  const B  = 4d1;
  const C  = 4d2;
  const D  = 4d3;
  const X  = 4d4;
  const Y  = 4d5;
  const BP = 4d6;
  const SP = 4d7;
  const IRQ_FLAGS = 4d8;
  const PC = 4d9;
  const MM = 4d10;
  const MP = 4d11;
}

global Flags {
  const EX = 3d7; // Exception
  const ID = 3d6; // IRQ Disable
  const IS = 3d5; // IRQ in service
  const SS = 3d4; // Single Step 
  const N = 3d3;  // negative
  const C = 3d2;  // carry 
  const V = 3d1;  // overflow 
  const Z = 3d0;  // zero 
}

global AddressModes {
  const IMMEDIATE = 2b00; // immediate (data is in the instruction)
  const ABSOLUTE = 2b01;  // absolute (data is at the address, potentially indirected & indexed
  const RELATIVE_BP = 2b10; // relative BP addressing, potentially indirected & indexed
  const ABSOLUTE_DX = 2b11; // absolute D,X addressing, potentially indirected & indexed
}

module cpu (
    input clk,  // clock
    input rst,  // reset
    input irq_service,   // trap reqeusted from I/O (read irq)
    input nmi,           // nmi (non-maskable interrupt)
    input  irq[16],      // IRQ signals from bus
    output irq_ack[16],  // IRQ acknowledgements
    input ready,         // ready pin (if 1, CPU will run)
    output address[19],  // 19-bit memory address selector
    output port[8],      // 8-bit I/O port selector
    
    input d_in[8],       // 8-bit data from memory (in)
    output d_out[8],     // 8-bit data to memory (out)
    output d_read,       // request read from memory
    input  d_rdy,        // if 1, data is ready to be read 
    output d_write,      // request write to memory
    input io_in[8],      // I/O data in 
    output io_out[8],    // I/O data out 
    output io_read,
    output io_write,
    input io_rdy,        // if 1, I/O is ready to be read
    input io_timeout,    // if 1, I/O request timed out

    /* debugging */    
    
    input dbe,             // debugger enabled
    output dbg_reg[12][16],// DEBUG output of all registers
    output dbg_inst[32],   // DEBUG output of instruction
    output dbg_clocks[32], // DEBUG clocks
    input dbg_reg_sel[4],  // register select
    input dbg_reg_data[16],// data to write into selected register 
    input dbg_reg_write    // if set, write the data into the register
    
  ) {

  .clk(clk) {
    .rst(rst) {
      dff reg[12][16];     // 12 16-bit registers (alternatively 24 8-bit registers)
      dff inst[4][8];      // 32-bit instruction
      dff instOpExec[8];   // Final instruction to execute (after decodes & fixups)
      fsm state = { INIT, FETCH_1, FETCH_2, FETCH_3, FETCH_4, DECODE_1, DECODE_2, EXECUTE, NEXT, HALT };
      fsm addrState = { START, IDX_X, INDIRECT_HI, INDIRECT_LO, IDX_Y, FETCH_WORD_HI, FETCH_WORD_LO, STORE_WORD_HI, STORE_WORD_LO };
      dff addrIndirect[16];
      dff ld_st_addr[19];
      //dff tmpData[16];
      dff cpu_clocks[16];
      dff inst_clocks[16]; 
      dff cpu_clocks_hold[16];
      dff inst_clocks_hold[16];
    }  
  }
    alu alu; 
  
  instLUT instLUT; 
  memory_mapper mapper;
  
  sig instSize[2];
  sig instOp[8];
  sig fixup[1];
  
  sig destReg[3];
  sig destRegSize[1];
  sig srceReg[3];
  sig srceRegSize[1];
  
  sig addr_mm[2];
  sig addr_i;
  sig addr_x;
  sig addr_y;
  sig addr_orig[19];
  //sig addr[19];
  //sig addr_idx_y[19];
  sig store;
  
  sig br_u;
  sig br_w;
  sig br_n;
  sig br_flg[3];
  
  sig skip[1];
    
  always {
    /* defaults */
    address = mapper.mapped_address; // the exposed address should always be mapped w/ MM
    port = 8hxx;                     // output port can float
    d_out = 8hxx;                    // output data can float
    io_out = 8hxx;                   // output IO data can float
    d_write = 1b0;                   // no memory write request
    d_read = 1b0;                    // no memory read request
    io_write = 1b0;                  // no io write request
    io_read = 1b0;                   // no io read request
    mapper.address = 19hxxx;         // mapper's address can float when we're not asserting anything
    mapper.mm = reg.q[Reg.MM][14:0]; // mapper's memory map is linked to register MM
    irq_ack = 16bx;
    
    alu.size_r = 1bx;
    alu.size_a = 1bx;
    alu.size_b = 1bx;
    alu.op = 4bx;
    alu.carry_in = 1bx;
    alu.a = 16bx;
    alu.b = 16bx;
    
    dbg_reg = reg.q;
    dbg_inst = c{inst.q[0], inst.q[1], inst.q[2], inst.q[3]};
    dbg_clocks = c{cpu_clocks_hold.q, inst_clocks_hold.q};
    if (dbg_reg_write) {
      reg.d[dbg_reg_sel] = dbg_reg_data;
    }
    
    instLUT.opcode = inst.q[0];      // wire up the first instruction byte to instLUT so we can calculate instruction size
    instSize = instLUT.out[9:8];     // size is the top two bytes of instLUT's return
    instOp = instLUT.out[7:0];       // actual opcode is the bottom eight bytes... or a FIXUP, in which case we have to 
                                     // fix up PC & the opcode. 
    inst_clocks.d = inst_clocks.q + 1;
    if (ready) {                     // ready means we are aren't waiting on any external resources (memory, etc.)
      cpu_clocks.d = cpu_clocks.q + 1;
      case (state.q) {
        state.INIT:
          reg.d[Reg.PC] = 16hFF00;   // Program Counter starts at 0xFF00 for bootstrap code (MMapped to 7FF00)
          reg.d[Reg.MP] = 16hFF00;   // Memory Pointer is same as PC
          reg.d[Reg.SP] = 16h2000;   // Stack Pointer is points at 0x2000
          reg.d[Reg.BP] = 16h2000;   // Base Poiner also points at 0x2000
          reg.d[Reg.MM] = 16b0111110001000001; // default memory mapping (page 3 = 31, page 2 = 2, page 1 = 1)
          reg.d[Reg.IRQ_FLAGS] = c{8h0,8b01000000}; // Interrupts are DISABLED until the bootstrap code in ROM enables them
          reg.d[Reg.IRQ_FLAGS][4] = dbe;         // if debugger is enabled, single step by default
          state.d = state.NEXT;     // start fetching instructions (but NEXT will let us halt immediately if need be)
  
        state.FETCH_1:
          mapper.address = c{3b000, reg.q[Reg.MP]}; // assert mapped address on address output
          d_read = 1b1;                             // request READ from memory
          if(d_rdy) {                               // when data is available
            reg.d[Reg.MP] = reg.q[Reg.MP] + 1;      // ... increment MP by one (ready for next byte, if needed)
            inst.d[0] = d_in;                       // ... set the instruction's first byte to the data
            inst.d[1] = 0;                          // ... clear the rest
            inst.d[2] = 0;
            inst.d[3] = 0;
            instLUT.opcode = d_in;                  // ... set the opcode to see if we need to read more
            state.d = instSize != InstWidth.ONE ? state.FETCH_2 : state.DECODE_1;
          }
          
        state.FETCH_2:
          mapper.address = c{3b000, reg.q[Reg.MP]}; // assert mapped address on address output
          d_read = 1b1;                             // request READ from memory
          if(d_rdy) {                               // when data is availabe
            reg.d[Reg.MP] = reg.q[Reg.MP] + 1;      // ... increment MP by one (ready for next byte, if needed)
            inst.d[1] = d_in;                       // ... populate second byte of instruction
            state.d = instSize != InstWidth.TWO ? state.FETCH_3 : state.DECODE_1;
          }
        state.FETCH_3:
          mapper.address = c{3b000, reg.q[Reg.MP]}; // read another byte from mapped memory
          d_read = 1b1;                             // request READ from memory
          if(d_rdy) {                               // when data is available
            reg.d[Reg.MP] = reg.q[Reg.MP] + 1;      // ... increment MP by one (ready for next byte, if needed)
            inst.d[2] = d_in;                       // ... populate third byte of instruction
            state.d = instSize != InstWidth.THREE ? state.FETCH_4 : state.DECODE_1;
          }
        state.FETCH_4:
          mapper.address = c{3b000, reg.q[Reg.MP]}; // read another byte from mapped memory
          d_read = 1b1;                             // request READ from memory
          if(d_rdy) {
            reg.d[Reg.MP] = reg.q[Reg.MP] + 1;      // ... increment MP by one (ready for next byte, if needed)
            inst.d[3] = d_in;                       // store final instruction byte
            state.d = state.DECODE_1;                 // no instruction is longer than four bytes; go to decoding
          }
        state.DECODE_1:
          reg.d[Reg.PC] = reg.q[Reg.MP];            // Move PC to match MP
          instOpExec.d = instOp;
          fixup = 1b0;                              // signal if we need a fixup -- 0 means no
          // fix ups -- need to account for having read too much of the instruction
          fixup = (instOp == Op.LD_FIXUP && inst.q[1] ==0 && inst.q[0][0]) ||
                  ((instOp == Op.LOOP_FIXUP || instOp == Op.BR_FIXUP) && inst.q[1][0]);
          if (fixup) {
            // move MP and PC back by one
            reg.d[Reg.MP] = reg.q[Reg.MP] - 1;
            reg.d[Reg.PC] = reg.q[Reg.MP] - 1;
          }

          case (instOp) {
            Op.NOT_NEG_EXC_FIXUP:                   // select the corret opcode based on second byte
              case (inst.q[1][5:4]) {
                2b00: instOpExec.d = Op.NOT_D;
                2b01: instOpExec.d = Op.NEG_D;
                2b10: instOpExec.d = Op.EXC_D;
                default: instOpExec.d = Op.INVALID;
              }
            Op.LD_FIXUP:
              if (inst.q[1] == 8h00) {
                instOpExec.d = inst.q[0][0] ? Op.LD_D_IMMB : Op.LD_D_IMMW;
              } else {
                instOpExec.d = Op.LD_D_ADDR;
              }
            Op.LOOP_FIXUP:
              instOpExec.d = inst.q[1][0] ? Op.LOOPS_ADR : Op.LOOP_ADDR;
            Op.BR_FIXUP:
              instOpExec.d = inst.q[1][0] ? Op.BRS_ADR : Op.BR_ADDR;
          }
          state.d = state.EXECUTE;
        state.EXECUTE:
          state.d = state.NEXT;

          if ((instOpExec.q >= Op.ADD_D_S && instOpExec.q <= Op.XOR_D_S) || (instOpExec.q >= Op.MUL_D_S && instOpExec.q <= Op.SMOD_D_S)
            || instOpExec.q == Op.SHL_D_S || instOpExec.q == Op.SHR_D_S) {
            destReg = inst.q[1][7:5];
            destRegSize = inst.q[1][4];
            srceReg = inst.q[1][3:1];
            srceRegSize = inst.q[1][0];
            alu.size_a = destRegSize;
            alu.a = destRegSize ? /* BYTE */ reg.q[destReg][7:0] : reg.q[destReg];
            alu.size_b = srceRegSize;
            alu.b = srceRegSize ? /* BYTE */ reg.q[srceReg][7:0] : reg.q[srceReg];
            alu.carry_in = reg.q[Reg.IRQ_FLAGS][2];
            skip = 0; // if skip isn't set, we'll store the result of aluOp back in dest
            case (instOpExec.q[2:0]) {
              Op.ADD_D_S: alu.op = AluOps.ADD;
              Op.SUB_D_S: alu.op = AluOps.SUB;
              Op.CMP_D_S: alu.op = AluOps.SUB; skip = 1; // cmp is subtract, but don't store result
              Op.AND_D_S: alu.op = AluOps.AND;
              Op.OR_D_S:  alu.op = AluOps.OR;
              Op.TEST_D_S: alu.op = AluOps.AND; skip = 1; // test is AND, but don't store result
              Op.XOR_D_S: alu.op = AluOps.XOR;
              Op.SHL_D_S: alu.op = AluOps.SHL;
              Op.SHR_D_S: alu.op = AluOps.SHR;
              Op.MUL_D_S: alu.op = AluOps.MUL;
              Op.MOD_D_S: alu.op = AluOps.MOD;
              Op.DIV_D_S: alu.op = AluOps.DIV;
              Op.SMUL_D_S: alu.op = AluOps.SMUL;
              Op.SMOD_D_S: alu.op = AluOps.SMOD;
              Op.SDIV_D_S: alu.op = AluOps.SDIV;
              default: alu.op = AluOps.ADD;
            }
            if (!skip) {
              if (destRegSize) /* BYTE */ reg.d[destReg][7:0] = alu.result[7:0];
              else             /* WORD */ reg.d[destReg] = alu.result;
            }
            reg.d[Reg.IRQ_FLAGS][3:0] = c{alu.negative, alu.carry, alu.overflow, alu.zero};              
          }
          
          if (instOpExec.q == Op.NOT_D || instOpExec.q == Op.NEG_D) {
            destReg = inst.q[1][3:1];
            destRegSize = inst.q[1][0];
            alu.size_a = destRegSize;
            alu.a = destRegSize ? /* BYTE */ reg.q[destReg][7:0] : reg.q[destReg];
            alu.op = (inst.q[1][4]) ? AluOps.NEG : AluOps.NOT;
            if (destRegSize) /* BYTE */ reg.d[destReg][7:0] = alu.result[7:0];
            else             /* WORD */ reg.d[destReg] = alu.result;
            reg.d[Reg.IRQ_FLAGS][3:0] = c{alu.negative, alu.carry, alu.overflow, alu.zero};            
          }
          
          if (instOpExec.q == Op.EXC_D) {
            destReg = inst.q[1][3:1];
            destRegSize = inst.q[1][0];
            if (destRegSize) /* BYTE */ { reg.d[destReg][7:4] = reg.q[destReg][3:0]; reg.d[destReg][3:0] = reg.q[destReg][7:4]; }
            else             /* WORD */ { reg.d[destReg][15:8]= reg.q[destReg][7:0]; reg.d[destReg][7:0] = reg.q[destReg][15:8]; }
            // NOTE: does NOT set flags (unlike emulator; not sure we actually need to, and can't see a use case)
          }
          
          if (instOpExec.q == Op.SWAP_D_S || instOpExec.q == Op.MOV_D_S) {
            destReg = inst.q[1][7:5];
            destRegSize = inst.q[1][4];
            srceReg = inst.q[1][3:1];
            srceRegSize = inst.q[1][0];
            if (destRegSize) /* BYTE */ reg.d[destReg][7:0] = reg.q[srceReg][7:0];
            else             /* WORD */ reg.d[destReg] = reg.q[srceReg];
            if (!instOpExec.q[0] /* SWAP */) {
              if (srceRegSize) /* BYTE */ reg.d[srceReg][7:0] = reg.q[destReg][7:0];
              else             /* WORD */ reg.d[srceReg] = reg.q[destReg];
            } 
          }
          
          if (instOpExec.q == Op.LD_D_IMMW) {
            destReg = inst.q[0][3:1];
            reg.d[destReg] = c{inst.q[2], inst.q[3]};
          }
          
          if (instOpExec.q == Op.LD_D_IMMB) {
            destReg = inst.q[0][3:1];
            reg.d[destReg][7:0] = inst.q[2];
          }
          
          if (instOpExec.q == Op.LD_D_ADDR || instOpExec.q == Op.ST_S_ADDR) {
            state.d = state.EXECUTE; // keep us in this state (we'll move forward after we ld or st)
            store = instOpExec.q == Op.ST_S_ADDR; //inst.q[0][5]; // if not set, loading
            destReg = inst.q[0][3:1];
            destRegSize = inst.q[0][0];
            addr_mm = inst.q[1][7:6];
            addr_i = inst.q[1][5];
            addr_x = inst.q[1][4];
            addr_y = inst.q[1][3];
            addr_orig = c{inst.q[1][2:0], inst.q[2], inst.q[3]};
                        
            case (addrState.q) {
              addrState.START:
                case (addr_mm) {
                  AddressModes.RELATIVE_BP: ld_st_addr.d = c{addr_orig[18:16], addr_orig[15:0] + reg.q[Reg.BP]};
                  AddressModes.ABSOLUTE_DX: ld_st_addr.d = addr_orig + c{reg.q[Reg.D], 3b0};
                  default:                  ld_st_addr.d = addr_orig;
                }
                addrState.d = addr_x ? addrState.IDX_X : (addr_i ? addrState.INDIRECT_HI : 
                              (store ? (destRegSize ? /*BYTE*/ addrState.STORE_WORD_LO : /*WORD*/ addrState.STORE_WORD_HI)
                                     : (destRegSize ? /*BYTE*/ addrState.FETCH_WORD_LO : /*WORD*/ addrState.FETCH_WORD_HI)));
              addrState.IDX_X:
                ld_st_addr.d = ld_st_addr.q + reg.q[Reg.X];
                addrState.d = addr_i ? addrState.INDIRECT_HI : 
                              (store ? (destRegSize ? /*BYTE*/ addrState.STORE_WORD_LO : /*WORD*/ addrState.STORE_WORD_HI)
                                     : (destRegSize ? /*BYTE*/ addrState.FETCH_WORD_LO : /*WORD*/ addrState.FETCH_WORD_HI));
              addrState.INDIRECT_HI:
                mapper.address = ld_st_addr.q;            // assert mapped address on address output
                d_read = 1b1;                             // request READ from memory
                if(d_rdy) {                               // when data is available
                  ld_st_addr.d = ld_st_addr.q + 1;          // advance memory ahead by one
                  addrIndirect.d[15:8] = d_in;            // load high bits of indirect address
                  state.d = addrState.INDIRECT_LO;        // next state
                }
              addrState.INDIRECT_LO:
                mapper.address = ld_st_addr.q;            // assert next mapped address on address output
                d_read = 1b1;                             // request READ from memory
                if(d_rdy) {                               // when data is available
                  addrIndirect.d[7:0] = d_in;             // load low bits of indirect address
                  ld_st_addr.d = c{addrIndirect.q[15:8], d_in};
                  addrState.d = addr_y ? addrState.IDX_Y :
                                (store ? (destRegSize ? /*BYTE*/ addrState.STORE_WORD_LO : /*WORD*/ addrState.STORE_WORD_HI)
                                       : (destRegSize ? /*BYTE*/ addrState.FETCH_WORD_LO : /*WORD*/ addrState.FETCH_WORD_HI));
                }
              addrState.IDX_Y:
                ld_st_addr.d = ld_st_addr.q + reg.q[Reg.Y];
                addrState.d = (store ? (destRegSize ? /*BYTE*/ addrState.STORE_WORD_LO : /*WORD*/ addrState.STORE_WORD_HI)
                                     : (destRegSize ? /*BYTE*/ addrState.FETCH_WORD_LO : /*WORD*/ addrState.FETCH_WORD_HI));
              addrState.FETCH_WORD_HI:
                mapper.address = ld_st_addr.q;
                d_read = 1b1;                             // request READ from memory
                if(d_rdy) {                               // when data is available
                  ld_st_addr.d = ld_st_addr.q + 1;          // advance mem by one
                  reg.d[destReg][15:8] = d_in;            // load in destination HI
                  addrState.d = addrState.FETCH_WORD_LO;
                }
              addrState.FETCH_WORD_LO:
                mapper.address = ld_st_addr.q;
                d_read = 1b1;                             // request READ from memory
                if(d_rdy) {                               // when data is available
                  reg.d[destReg][7:0] = d_in;             // load in destination LO
                  addrState.d = addrState.START;
                  state.d = state.NEXT;                   // done; continue execution
                }
              addrState.STORE_WORD_HI:
                mapper.address = ld_st_addr.q;
                ld_st_addr.d = ld_st_addr.q + 1;          // advance mem by one
                d_out = reg.q[destReg][15:8];             // store HI portion to memory
                d_write = 1b1;                            // request WRITE to memory; we'll be paused until it's written
                addrState.d = addrState.STORE_WORD_LO;
              addrState.STORE_WORD_LO:
                mapper.address = ld_st_addr.q;
                d_out = reg.q[destReg][7:0];              // store LO portion to memory
                d_write = 1b1;                            // request WRITE to memory; we'll be paused until it's written
                addrState.d = addrState.START;
                state.d = state.NEXT;                     // done; continue execution
            }
          }
          
          if (instOpExec.q == Op.INC_D || instOpExec.q == Op.DEC_D || instOpExec.q == Op.LOOPS_ADR) {
            destReg = inst.q[0][3:1];
            destRegSize = inst.q[0][0];
            alu.size_a = destRegSize;
            alu.a = destRegSize ? /* BYTE */ c{8h00, reg.q[destReg][7:0]} : /* WORD */ reg.q[destReg];
            alu.op = (instOpExec.q == Op.INC_D) ? AluOps.INC : AluOps.DEC;
            reg.d[Reg.IRQ_FLAGS][3:0] = c{alu.negative, alu.carry, alu.overflow, alu.zero};
            if (destRegSize) /* BYTE */ reg.d[destReg][7:0] = alu.result[7:0];
            else             /* WORD */ reg.d[destReg] = alu.result;
            
            if (instOpExec.q == Op.LOOPS_ADR) {
              if (!alu.carry) {
                // THIS IS NOT COMPLETE; NO HANDLING OF ADDRESSING MODES ATM
                // jumps need to be sign extended when using eight bit short addresses
                
                reg.d[Reg.MP] = reg.q[Reg.MP] + c{inst.q[2][7] ? 8hFF : 8h00, inst.q[2]};
              }
            }
          }
          
          if (instOpExec.q == Op.IN_D_IMMB) {
            destReg = inst.q[1][7:5];
            destRegSize = inst.q[1][4];
            io_read = ~io_rdy;
            port = inst.q[2]; 
            if (io_timeout) reg.d[Reg.IRQ_FLAGS][7] = 1; // set EXception when IO times out
            if (io_rdy) {
              if (destRegSize) /* BYTE */ reg.d[destReg][7:0] = io_in;
              else             /* WORD */ reg.d[destReg] = c{8h00, io_in};
            } else state.d = state.EXECUTE; // stick around for another cycle
          }
          
          if (instOpExec.q == Op.OUT_S_IMMB) {
            srceReg = inst.q[1][7:5];
            srceRegSize = inst.q[1][4];
            io_out = reg.q[srceReg][7:0];
            io_write = 1;
            port = inst.q[2];
          }
              
          if ((instOpExec.q == Op.BRK && dbe) || instOpExec.q == Op.HALT)
              state.d = state.HALT;
          
        state.NEXT: 
          // TODO: handle IRQs
          state.d = state.FETCH_1;                  // when done, go back to fetch the next instruction
          if (dbe & reg.q[Reg.IRQ_FLAGS][4]) {      // unless debugger is attached and single step enabled
            state.d = state.HALT;                   // ... in which case, halt
          }
          cpu_clocks_hold.d = cpu_clocks.q;
          inst_clocks_hold.d = inst_clocks.q;

          cpu_clocks.d = 0;
          inst_clocks.d = 0;
          
        state.HALT:
          if (irq_service & nmi) {                  // wait until trap asserted, IRQ has high bit, so NMI
            state.d = state.FETCH_1;                // ... continue execution
            cpu_clocks.d = 0;
            inst_clocks.d = 0;
          }
      }
    }
  }
}
