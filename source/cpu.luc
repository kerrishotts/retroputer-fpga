global Reg {
  const A  = 4d0;
  const B  = 4d1;
  const C  = 4d2;
  const D  = 4d3;
  const X  = 4d4;
  const Y  = 4d5;
  const BP = 4d6;
  const SP = 4d7;
  const IRQ_FLAGS = 4d8;
  const PC = 4d9;
  const MM = 4d10;
  const MP = 4d11;
}

module cpu (
    input clk,  // clock
    input rst,  // reset
    input trap,          // trap reqeusted from I/O (read irq)
    input  irq[16],      // IRQ signals from bus
    output irq_ack[16],  // IRQ acknowledgements
    input ready,         // ready pin (if 1, CPU will run)
    output address[19],  // 19-bit memory address selector
    output port[8],      // 8-bit I/O port selector
    
    input d_in[8],       // 8-bit data from memory (in)
    output d_out[8],     // 8-bit data to memory (out)
    output d_read,       // request read from memory
    input  d_rdy,        // if 1, data is ready to be read 
    output d_write,      // request write to memory
    input io_in[8],      // I/O data in 
    output io_out[8],    // I/O data out 
    output io_read,
    output io_write,
    input io_rdy,        // if 1, I/O is ready to be read

    /* debugging */    
    
    input dbe,             // debugger enabled
    input dbg_reg_sel[4],  // register select
    output dbg_reg_val[16],// output of the register being selected
    input dbg_reg_data[16],// data to write into selected register 
    input dbg_reg_write    // if set, write the data into the register
    
  ) {

  .clk(clk) {
    .rst(rst) {
      dff reg[12][16];     // 12 16-bit registers (alternatively 24 8-bit registers)
      dff inst[4][8];      // 32-bit instruction
      dff instOpExec[8];   // Final instruction to execute (after decodes & fixups)
      fsm state = { INIT, FETCH_1, FETCH_2, FETCH_3, FETCH_4, DECODE_1, DECODE_2, EXECUTE, NEXT, HALT };
    }  
  }
    alu alu; 
  
  instLUT instLUT; 
  memory_mapper mapper;
  
  sig instSize[2];
  sig instOp[8];
  sig fixup[1];
  
  sig destReg[3];
  sig destRegSize[1];
  sig srceReg[3];
  sig srceRegSize[1];
  
  sig skip[1];
    
  always {
    /* defaults */
    address = mapper.mapped_address; // the exposed address should always be mapped w/ MM
    port = 8hxx;                     // output port can float
    d_out = 8hxx;                    // output data can float
    io_out = 8hxx;                   // output IO data can float
    d_write = 1b0;                   // no memory write request
    d_read = 1b0;                    // no memory read request
    io_write = 1b0;                  // no io write request
    io_read = 1b0;                   // no io read request
    mapper.address = 19hxxx;         // mapper's address can float when we're not asserting anything
    mapper.mm = reg.q[Reg.MM][14:0]; // mapper's memory map is linked to register MM
    irq_ack = 16bx;
    
    alu.size_r = 1bx;
    alu.size_a = 1bx;
    alu.size_b = 1bx;
    alu.op = 4bx;
    alu.carry_in = 1bx;
    alu.a = 16bx;
    alu.b = 16bx;
    
    dbg_reg_val = reg.q[dbg_reg_sel];// output the selected register for debugging purposes
    if (dbg_reg_write) {
      reg.d[dbg_reg_sel] = dbg_reg_data;
    }
    
    instLUT.opcode = inst.q[0];      // wire up the first instruction byte to instLUT so we can calculate instruction size
    instSize = instLUT.out[9:8];     // size is the top two bytes of instLUT's return
    instOp = instLUT.out[7:0];       // actual opcode is the bottom eight bytes... or a FIXUP, in which case we have to 
                                     // fix up PC & the opcode. 
    
    if (ready) {                     // ready means we are aren't waiting on any external resources (memory, etc.)
      case (state.q) {
        state.INIT:
          reg.d[Reg.PC] = 16hFF00;   // Program Counter starts at 0xFF00 for bootstrap code (MMapped to 7FF00)
          reg.d[Reg.MP] = 16hFF00;   // Memory Pointer is same as PC
          reg.d[Reg.SP] = 16h2000;   // Stack Pointer is points at 0x2000
          reg.d[Reg.BP] = 16h2000;   // Base Poiner also points at 0x2000
          reg.d[Reg.MM] = 16b0111110001000001; // default memory mapping (page 3 = 31, page 2 = 2, page 1 = 1)
          reg.d[Reg.IRQ_FLAGS] = c{8h0,8b01000000}; // Interrupts are DISABLED until the bootstrap code in ROM enables them
          reg.d[Reg.IRQ_FLAGS][4] = dbe;         // if debugger is enabled, single step by default
          state.d = state.NEXT;     // start fetching instructions (but NEXT will let us halt immediately if need be)
  
        state.FETCH_1:
          mapper.address = c{3b000, reg.q[Reg.MP]}; // assert mapped address on address output
          d_read = 1b1;                             // request READ from memory
          if(d_rdy) {                               // when data is available
            reg.d[Reg.MP] = reg.q[Reg.MP] + 1;      // ... increment MP by one (ready for next byte, if needed)
            inst.d[0] = d_in;                       // ... set the instruction's first byte to the data
            inst.d[1] = 0;                          // ... clear the rest
            inst.d[2] = 0;
            inst.d[3] = 0;
            instLUT.opcode = d_in;                  // ... set the opcode to see if we need to read more
            state.d = instSize != InstWidth.ONE ? state.FETCH_2 : state.DECODE_1;
          }
          
        state.FETCH_2:
          mapper.address = c{3b000, reg.q[Reg.MP]}; // assert mapped address on address output
          d_read = 1b1;                             // request READ from memory
          if(d_rdy) {                               // when data is availabe
            reg.d[Reg.MP] = reg.q[Reg.MP] + 1;      // ... increment MP by one (ready for next byte, if needed)
            inst.d[1] = d_in;                       // ... populate second byte of instruction
            state.d = instSize != InstWidth.TWO ? state.FETCH_3 : state.DECODE_1;
          }
        state.FETCH_3:
          mapper.address = c{3b000, reg.q[Reg.MP]}; // read another byte from mapped memory
          d_read = 1b1;                             // request READ from memory
          if(d_rdy) {                               // when data is available
            reg.d[Reg.MP] = reg.q[Reg.MP] + 1;      // ... increment MP by one (ready for next byte, if needed)
            inst.d[2] = d_in;                       // ... populate third byte of instruction
            state.d = instSize != InstWidth.THREE ? state.FETCH_4 : state.DECODE_1;
          }
        state.FETCH_4:
          mapper.address = c{3b000, reg.q[Reg.MP]}; // read another byte from mapped memory
          d_read = 1b1;                             // request READ from memory
          if(d_rdy) {
            reg.d[Reg.MP] = reg.q[Reg.MP] + 1;      // ... increment MP by one (ready for next byte, if needed)
            inst.d[3] = d_in;                       // store final instruction byte
            state.d = state.DECODE_1;                 // no instruction is longer than four bytes; go to decoding
          }
        state.DECODE_1:
          reg.d[Reg.PC] = reg.q[Reg.MP];            // Move PC to match MP
          instOpExec.d = instOp;
          fixup = 1b0;                              // signal if we need a fixup -- 0 means no
          // fix ups -- need to account for having read too much of the instruction
          fixup = (instOp == Op.LD_FIXUP && inst.q[1] ==0 && inst.q[0][0]) ||
                  ((instOp == Op.LOOP_FIXUP || instOp == Op.BR_FIXUP) && inst.q[1][0]);
/*                
          case (instOp) {
            Op.LD_FIXUP:                            // if loading absolute with AL-DL, need fixup
              if (inst.q[1] == 8h00 && inst.q[0][0]) {
                fixup = 1b1;
              }
            Op.LOOP_FIXUP:                          // if short flag is specified on LOOP or BR, fixup
              if (inst.q[1][0]) {
                fixup = 1b1;
              }
            Op.BR_FIXUP:
              if (inst.q[1][0]) {
                fixup = 1b1;
              }
          }
*/          
          if (fixup) {
            // move MP and PC back by one
            reg.d[Reg.MP] = reg.q[Reg.MP] - 1;
            reg.d[Reg.PC] = reg.q[Reg.MP] - 1;
          }
          state.d = state.DECODE_2;                  // we've got enough to continue
        state.DECODE_2:
          case (instOp) {
            Op.NOT_NEG_EXC_FIXUP:                   // select the corret opcode based on second byte
              case (inst.q[1][5:4]) {
                2b00: instOpExec.d = Op.NOT_D;
                2b01: instOpExec.d = Op.NEG_D;
                2b10: instOpExec.d = Op.EXC_D;
                default: instOpExec.d = Op.INVALID;
              }
            Op.LD_FIXUP:
              if (inst.q[1] == 8h00) {
                instOpExec.d = inst.q[0][0] ? Op.LD_D_IMMB : Op.LD_D_IMMW;
              } else {
                instOpExec.d = Op.LD_D_ADDR;
              }
            Op.LOOP_FIXUP:
              instOpExec.d = inst.q[1][0] ? Op.LOOPS_ADR : Op.LOOP_ADDR;
            Op.BR_FIXUP:
              instOpExec.d = inst.q[1][0] ? Op.BRS_ADR : Op.BR_ADDR;
          }
          state.d = state.EXECUTE;
        state.EXECUTE:
          state.d = state.NEXT;

          if ((instOpExec.q >= Op.ADD_D_S && instOpExec.q <= Op.XOR_D_S) || (instOpExec.q >= Op.MUL_D_S && instOpExec.q <= Op.SMOD_D_S)
            || instOpExec.q == Op.SHL_D_S || instOpExec.q == Op.SHR_D_S) {
            destReg = inst.q[1][7:5];
            destRegSize = inst.q[1][4];
            srceReg = inst.q[1][3:1];
            srceRegSize = inst.q[1][0];
            alu.size_a = destRegSize;
            alu.a = destRegSize ? /* BYTE */ reg.q[destReg][7:0] : reg.q[destReg];
            alu.size_b = srceRegSize;
            alu.b = srceRegSize ? /* BYTE */ reg.q[srceReg][7:0] : reg.q[srceReg];
            alu.carry_in = reg.q[Reg.IRQ_FLAGS][2];
            skip = 0; // if skip isn't set, we'll store the result of aluOp back in dest
            case (instOpExec.q[2:0]) {
              default: alu.op = AluOps.ADD;
              Op.ADD_D_S: alu.op = AluOps.ADD;
              Op.SUB_D_S: alu.op = AluOps.SUB;
              Op.CMP_D_S: alu.op = AluOps.SUB; skip = 1; // cmp is subtract, but don't store result
              Op.AND_D_S: alu.op = AluOps.AND;
              Op.OR_D_S:  alu.op = AluOps.OR;
              Op.TEST_D_S: alu.op = AluOps.AND; skip = 1; // test is AND, but don't store result
              Op.XOR_D_S: alu.op = AluOps.XOR;
              Op.SHL_D_S: alu.op = AluOps.SHL;
              Op.SHR_D_S: alu.op = AluOps.SHR;
              Op.MUL_D_S: alu.op = AluOps.MUL;
              Op.MOD_D_S: alu.op = AluOps.MOD;
              Op.DIV_D_S: alu.op = AluOps.DIV;
              Op.SMUL_D_S: alu.op = AluOps.SMUL;
              Op.SMOD_D_S: alu.op = AluOps.SMOD;
              Op.SDIV_D_S: alu.op = AluOps.SDIV;
            }
            if (!skip) {
              if (destRegSize) /* BYTE */ reg.d[destReg][7:0] = alu.result[7:0];
              else             /* WORD */ reg.d[destReg] = alu.result;
            }
            reg.d[Reg.IRQ_FLAGS][3:0] = c{alu.negative, alu.carry, alu.overflow, alu.zero};              
          }
          
          if (instOpExec.q == Op.LD_D_IMMW) {
            destReg = inst.q[0][3:1];
            reg.d[destReg] = c{inst.q[2], inst.q[3]};
          }
          
          if (instOpExec.q == Op.LD_D_IMMB) {
            destReg = inst.q[0][3:1];
            reg.d[destReg][7:0] = inst.q[2];
          }
          
          if (instOpExec.q == Op.INC_D || instOpExec.q == Op.DEC_D || instOpExec.q == Op.LOOPS_ADR) {
            destReg = inst.q[0][3:1];
            destRegSize = inst.q[0][0];
            alu.size_a = destRegSize;
            alu.a = destRegSize ? /* BYTE */ c{8h00, reg.q[destReg][7:0]} : /* WORD */ reg.q[destReg];
            alu.op = (instOpExec.q == Op.INC_D) ? AluOps.INC : AluOps.DEC;
            reg.d[Reg.IRQ_FLAGS][3:0] = c{alu.negative, alu.carry, alu.overflow, alu.zero};
            if (destRegSize) /* BYTE */ reg.d[destReg][7:0] = alu.result[7:0];
            else             /* WORD */ reg.d[destReg] = alu.result;
            
            if (instOpExec.q == Op.LOOPS_ADR) {
              if (!alu.carry) {
                // THIS IS NOT COMPLETE; NO HANDLING OF ADDRESSING MODES ATM
                // jumps need to be sign extended when using eight bit short addresses
                
                reg.d[Reg.MP] = reg.q[Reg.MP] + c{inst.q[2][7] ? 8hFF : 8h00, inst.q[2]};
              }
            }
          }
          
          if (instOpExec.q == Op.IN_D_IMMB) {
            destReg = inst.q[1][7:5];
            destRegSize = inst.q[1][4];
            io_read = ~io_rdy;
            port = inst.q[2]; 
            if (io_rdy) {
              if (destRegSize) /* BYTE */ reg.d[destReg][7:0] = io_in;
              else             /* WORD */ reg.d[destReg] = c{8h00, io_in};
            } else state.d = state.EXECUTE; // stick around for another cycle
          }
          
          if (instOpExec.q == Op.OUT_S_IMMB) {
            srceReg = inst.q[1][7:5];
            srceRegSize = inst.q[1][4];
            io_out = reg.q[srceReg][7:0];
            io_write = 1;
            port = inst.q[2];
          }
              
          if ((instOpExec.q == Op.BRK && dbe) || instOpExec.q == Op.HALT)
              state.d = state.HALT;
          
        state.NEXT: 
          state.d = state.FETCH_1;                  // when done, go back to fetch the next instruction
          if (dbe & reg.q[Reg.IRQ_FLAGS][4]) {      // unless debugger is attached and single step enabled
            state.d = state.HALT;                   // ... in which case, halt
          }
        state.HALT:
          if (trap & irq[7]) {                      // wait until trap asserted, IRQ has high bit, so NMI
            state.d = state.FETCH_1;                // ... continue execution
          }
      }
    }
  }
}
