module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    /* DDR3 Connections */
    inout ddr3_dq[16],
    inout ddr3_dqs_n[2],
    inout ddr3_dqs_p[2],
    output ddr3_addr[14],
    output ddr3_ba[3],
    output ddr3_ras_n,
    output ddr3_cas_n,
    output ddr3_we_n,
    output ddr3_reset_n,
    output ddr3_ck_p,
    output ddr3_ck_n,
    output ddr3_cke,
    output ddr3_cs_n,
    output ddr3_dm[2],
    output ddr3_odt,
    /* IO board */
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal
  
  sig frontSel[2];          // select what info to show on front LEDs
  
  sig dbe;                  // debugger attached
  sig hideROM;              // if 1, ROM addresses read from RAM
  
  clk_wiz_0 clk_wiz;

  rom rom;
  // DDR3 Interface - connect inouts directly
  mig_wrapper mig (.ddr3_dq(ddr3_dq), .ddr3_dqs_n(ddr3_dqs_n), .ddr3_dqs_p(ddr3_dqs_p) );
  
  .clk(mig.ui_clk) {
    //edge_detector rdy_edge_detector(#RISE(1), #FALL(0)); // detect rising edges
    //button_conditioner rdy_button_cond;     // button input conditioner

    edge_detector nmi_edge_detector(#RISE(1), #FALL(0)); // detect rising edges
    button_conditioner nmi_button_cond;     // button input conditioner

    edge_detector up_edge_detector(#RISE(1), #FALL(0)); // detect rising edges
    button_conditioner up_button_cond;     // button input conditioner

    edge_detector down_edge_detector(#RISE(1), #FALL(0)); // detect rising edges
    button_conditioner down_button_cond;     // button input conditioner
        
    .rst(rst) {
      cpu cpu;
      lru_cache cache(#ENTRIES(1), #WORD_SIZE(8), #AGE_BITS(1));
      fsm state = { RUN_CPU, WAIT_MEM_READ, WAIT_IO_READ, WAIT_IO_READ_RDY, WAIT_IO_WRITE_RDY };
      //fsm regint = { RUN, WAIT_READ, READ_IO };
      multi_seven_seg seg;
      
      dff reg_select[4];
      dff port_select[8];
      
      dff waiting_for_io[1];
      dff waiting_for_io_write[1];
      dff waiting_for_io_read[1];
      dff led_waiting_for_io_read[1];
      dff waiting_for_mem[1];
      dff waiting_for_mem_write[1];
      dff waiting_for_mem_read[1];
      dff mem_read[8];
      dff io_read[8];

      #CLK_FREQ(81250000) {
        reg_interface reg_interface;
          #BAUD(1000000) {        // The baud rate of the uarts
            uart_rx uart_rx;      // The uart required by the register interace
            uart_tx uart_tx;      // The uart required by the register interace
          }
        }
      
      bus bus;
    }
  }
  
  always {
    /* register interface; setup from https://github.com/chuckb/AuHelloWorld/blob/main/fpga/source/au_top.luc */
    usb_tx = uart_tx.tx;
    uart_rx.rx = usb_rx;
    uart_tx.block = 0;
    uart_tx.new_data = reg_interface.new_tx_data;
    uart_tx.data = reg_interface.tx_data;
    reg_interface.tx_busy = uart_tx.busy;
    reg_interface.new_rx_data = uart_rx.new_data;
    reg_interface.rx_data = uart_rx.data;
    reg_interface.regIn.drdy = 0;
    reg_interface.regIn.data = 32bx;
        
    /* Clock Wizard Connections */
    clk_wiz.clk_in1 = clk; // 100MHz in
    clk_wiz.reset = !rst_n; // reset signal
    
    /* DDR3 Connections */
    ddr3_addr = mig.ddr3_addr;
    ddr3_ba = mig.ddr3_ba;
    ddr3_ras_n = mig.ddr3_ras_n;
    ddr3_cas_n = mig.ddr3_cas_n;
    ddr3_we_n = mig.ddr3_we_n;
    ddr3_reset_n = mig.ddr3_reset_n;
    ddr3_ck_p = mig.ddr3_ck_p;
    ddr3_ck_n = mig.ddr3_ck_n;
    ddr3_cke = mig.ddr3_cke;
    ddr3_cs_n = mig.ddr3_cs_n;
    ddr3_dm = mig.ddr3_dm;
    ddr3_odt = mig.ddr3_odt;
     
    mig.sys_clk = clk_wiz.clk_out1; // 100MHz clock
    mig.clk_ref = clk_wiz.clk_out2; // 200MHz clock
    mig.sys_rst = !clk_wiz.locked;  // reset when clk_wiz isn't locked
    rst = mig.sync_rst;             // use the reset signal from the mig core
  
    /* wire up the LRU cache */
    mig.mem_in = cache.mem_in;
    cache.mem_out = mig.mem_out;
    
    cache.flush = 0; // don't need to flush
    cache.wr_addr = cpu.address;
    cache.wr_data = cpu.d_out;
    cache.wr_valid = 0;
    cache.rd_addr = cpu.address;
    cache.rd_cmd_valid = 0;

    /* buttons & edge conditioners */    
    up_button_cond.in = io_button[0];
    up_edge_detector.in = up_button_cond.out;

    down_button_cond.in = io_button[2];
    down_edge_detector.in = down_button_cond.out;

    nmi_button_cond.in = io_button[3];
    nmi_edge_detector.in = nmi_button_cond.out;
        
    //rdy_button_cond.in = io_button[1];
    //rdy_edge_detector.in = rdy_button_cond.out;
    
    led = c{2h00, io_button[0], io_button[1], io_button[2], io_button[3], io_dip[0][0], rst};
    
    dbe = io_dip[0][0];
    hideROM = io_dip[0][7];
    
    bus.io_read = 0;
    bus.io_write = 0;
    cpu.trap = bus.irq_request;
    cpu.ready = 0;
    cpu.dbe = dbe;
    cpu.irq = bus.irq;
    bus.irq_ack = cpu.irq_ack;
    cpu.io_in = bus.io_out;
    bus.io_in = cpu.io_out;
    bus.io_addr = cpu.port;
    
    cpu.d_in = 8hxx;
    cpu.d_rdy = 0;
    cpu.io_rdy = 0;
    cpu.dbg_reg_data = 16hxx;
    cpu.dbg_reg_write = 0;
    cpu.dbg_reg_sel = 4hx;
    
    rom.addr = cpu.address[15:0]; // rom can be wired up to the lower 16 bits on the address line by default
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    seg.values = {4h0,4h0,4h0,4h0};
    seg.dots = 4h0;
    io_seg = ~seg.seg;           // connect segments to the driver
    io_sel = ~seg.sel;           // connect digit select to the driver

    frontSel = io_dip[2][7:6];

    case (frontSel) {
      2b00:
        if (up_edge_detector.out) {
            reg_select.d = reg_select.q == 11 ? 0 : reg_select.q + 1; // wrap back to zero after 12 registers    
        }
        if (down_edge_detector.out) {
            reg_select.d = reg_select.q == 0 ? 11 : reg_select.q - 1; // wrap back to 11 after going past first register
        }
        cpu.dbg_reg_sel = reg_select.q;
        
        
        // show memory address on LEDs
        io_led = {c{cache.rd_ready, cache.rd_data_valid, cache.wr_ready, 2b0, cpu.address[18:16]}, cpu.address[15:8], cpu.address[7:0]};
        
        seg.values = {cpu.dbg_reg_val[15:12], cpu.dbg_reg_val[11:8], cpu.dbg_reg_val[7:4], cpu.dbg_reg_val[3:0]}; // show selected register on IO 7Seg
        seg.dots = reg_select.q;     // dots represent selected register for debugging
        if (nmi_edge_detector.out) { // user pressed NMI button
          cpu.trap = 1;              // tell the CPU it's had a trap
          cpu.irq = 8hff;            // assert NMI, trap 127
        }
      2b10:
        if (up_edge_detector.out) {
            port_select.d = port_select.q + 1; 
          io_read.d = port_select.q;
        }
        if (down_edge_detector.out) {
            port_select.d = port_select.q - 1;
          io_read.d = port_select.q;
        }
        bus.io_addr = port_select.q;
        if (bus.rdy) {
          led_waiting_for_io_read.d = 1;
          bus.io_read = 1;
          if (bus.rd_valid) {
            io_read.d = bus.io_out;
            led_waiting_for_io_read.d = 0;
          }
        }
        if (led_waiting_for_io_read.q) {
          if (bus.rd_valid) {
            io_read.d = bus.io_out;
            led_waiting_for_io_read.d = 0;
          }
        }
        seg.values = {port_select.q[7:4], port_select.q[3:0], io_read.q[7:4], io_read.q[3:0]}; // show selected register on IO 7Seg
        if (nmi_edge_detector.out) { // user pressed NMI button, write middle DIPs to IO
          bus.io_in = io_dip[1];
          bus.io_write = 1;
        }
      
    }

    
    
    /* handle register interface commands */
    if (reg_interface.regOut.new_cmd) {
      if (reg_interface.regOut.write) {
        case (reg_interface.regOut.address[31:30]) {
          2b00: // write to RAM
            waiting_for_mem.d = 1;
            waiting_for_mem_write.d = 1;
          2b01: // tell CPU to single step
            cpu.trap = 1;              // tell the CPU it's had a trap
            cpu.irq = 8hff;            // assert NMI, trap 127
          2b10: // write i/o 
            waiting_for_io.d = 1;
            waiting_for_io_write.d = 1;
          2b11: // write register 
            cpu.dbg_reg_sel = reg_interface.regOut.address[3:0];
            cpu.dbg_reg_data = reg_interface.regOut.data[15:0]; 
            cpu.dbg_reg_write = 1;        

        }
      } else {
        case (reg_interface.regOut.address[31:30]) {
          2b00: 
            waiting_for_mem.d = 1;
            waiting_for_mem_read.d = 1;
          2b10: // read i/o 
            waiting_for_io.d = 1;
            waiting_for_io_read.d = 1;

          2b11: // read register
            cpu.dbg_reg_sel = reg_interface.regOut.address[3:0];
            reg_interface.regIn.data = cpu.dbg_reg_val;
            reg_interface.regIn.drdy = 1;
            
          //default:
            //reg_interface.regIn.data = 0;
            //reg_interface.regIn.drdy = 1;
        }
      }
    }
    if (waiting_for_mem.q) {
      if (waiting_for_mem_write.q) {
        if (cache.wr_ready) {
          cache.wr_addr = reg_interface.regOut.address[18:0];
          cache.wr_data = reg_interface.regOut.data[7:0];
          cache.wr_valid = 1;
          waiting_for_mem.d = 0;
          waiting_for_mem_write.d = 0;
        }
      }
      if (waiting_for_mem_read.q) {
        if (cache.rd_ready) {
          cache.rd_addr = reg_interface.regOut.address[18:0];
          cache.rd_cmd_valid = 1;
        }
        if (cache.rd_data_valid) {
          reg_interface.regIn.data = cache.rd_data[7:0];
          reg_interface.regIn.drdy = 1;
          waiting_for_mem_read.d = 0; 
          waiting_for_mem.d = 0;
        }
      }
    }
    if (waiting_for_io.q) {
      if (waiting_for_io_write.q) {
        if (bus.rdy) {
          bus.io_write = 1;
          bus.io_addr = reg_interface.regOut.address[7:0];
          bus.io_in = reg_interface.regOut.data[7:0];
          waiting_for_io.d = 0;
          waiting_for_io_write.d = 0;
        }
      }
      if (waiting_for_io_read.q) {
        if (bus.rdy) {
          bus.io_addr = reg_interface.regOut.address[7:0];
          bus.io_read = 1;
        }
        if (bus.rd_valid) {
          reg_interface.regIn.data = bus.io_out;
          reg_interface.regIn.drdy = 1;
          waiting_for_io.d = 0;
          waiting_for_io_read.d = 0;
        }
      }
    }     
    
    if (!(waiting_for_io.q || waiting_for_mem.q)) {
      case (state.q) {
        state.RUN_CPU:
          cpu.ready = 1;
          if (cpu.d_read) {                    // CPU is requesting to read data from memory
            if (&cpu.address[18:16] && !hideROM) {  // if the address is in bank 7 (111_xxxxxxxx_xxxxxxxx)
              cpu.d_in = rom.out;              // get the byte from ROM and give it to the CPU
              cpu.d_rdy = 1;                   // signal the CPU that it has data
            } else {
              if (cache.rd_ready) {            // otherwise it's asking to read from RAM... but that takes time
                cache.rd_cmd_valid = 1;        // ... ask cache to read from address
                state.d = state.WAIT_MEM_READ; // ... and wait
              }
            }
          }
          if (cpu.d_write) {                   // requesting to write to memory
            if (cache.wr_ready) {              // ... wait for the cache to be write ready 
              cache.wr_valid = 1;              // ... notify cache to write the data; note no mask for ROM -- can't be read anyway.
            }
          }
          
          if (cpu.io_read) {
            state.d = state.WAIT_IO_READ_RDY;
          }
          if (cpu.io_write) {
            state.d = state.WAIT_IO_WRITE_RDY;
          }
        state.WAIT_MEM_READ:                   // Waiting for data from RAM
          if (cache.rd_data_valid) {           // If data is available
            cpu.ready = 1;                     // ... CPU can run 
            cpu.d_in = cache.rd_data;          // ... send the data in
            cpu.d_rdy = 1;                     // ... and notify CPU
            state.d = state.RUN_CPU;           // ... move back to RUN CPU
          }
        state.WAIT_IO_READ_RDY:
          if (bus.rdy) {
              bus.io_read = 1;
              state.d = state.WAIT_IO_READ;
          }
        state.WAIT_IO_READ:
          if (bus.rd_valid) {                  // wait until we get data back from device
            cpu.ready = 1;                     // ... CPU can run
            cpu.io_rdy = 1;                    // ... notify CPU that IO data is valid (it's already wired up)
            state.d = state.RUN_CPU;           // ... move back to RUN CPU
          }
        state.WAIT_IO_WRITE_RDY:
          if (bus.rdy) {
            bus.io_write = 1;
            cpu.ready = 1;
            state.d = state.RUN_CPU;
          }
      }
    }
  }
}