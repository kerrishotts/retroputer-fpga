module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    /* DDR3 Connections */
    inout ddr3_dq[16],
    inout ddr3_dqs_n[2],
    inout ddr3_dqs_p[2],
    output ddr3_addr[14],
    output ddr3_ba[3],
    output ddr3_ras_n,
    output ddr3_cas_n,
    output ddr3_we_n,
    output ddr3_reset_n,
    output ddr3_ck_p,
    output ddr3_ck_n,
    output ddr3_cke,
    output ddr3_cs_n,
    output ddr3_dm[2],
    output ddr3_odt,
    /* IO board */
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal
  
  sig frontSel[2];          // select what info to show on front LEDs
  
  sig dbe;                  // debugger attached
  sig hideROM;              // if 1, ROM addresses read from RAM
  
  clk_wiz_0 clk_wiz;

  rom rom;
  // DDR3 Interface - connect inouts directly
  mig_wrapper mig (.ddr3_dq(ddr3_dq), .ddr3_dqs_n(ddr3_dqs_n), .ddr3_dqs_p(ddr3_dqs_p) );
  
  .clk(mig.ui_clk) {
    //edge_detector rdy_edge_detector(#RISE(1), #FALL(0)); // detect rising edges
    //button_conditioner rdy_button_cond;     // button input conditioner

    edge_detector nmi_edge_detector(#RISE(1), #FALL(0)); // detect rising edges
    button_conditioner nmi_button_cond;     // button input conditioner

    edge_detector up_edge_detector(#RISE(1), #FALL(0)); // detect rising edges
    button_conditioner up_button_cond;     // button input conditioner

    edge_detector down_edge_detector(#RISE(1), #FALL(0)); // detect rising edges
    button_conditioner down_button_cond;     // button input conditioner
        
    .rst(rst) {
      cpu cpu;
      ddr_arbiter mem_arbiter(#DEVICES(2));
      lru_cache cache(#ENTRIES(1), #WORD_SIZE(16), #AGE_BITS(1));
      fsm state = { RUN_CPU, WAIT_MEM_READ, WAIT_MEM_WRITE, WAIT_IO_READ, WAIT_IO_READ_RDY, WAIT_IO_WRITE_RDY, MEM_FLUSH_CACHE };
      //fsm regint = { RUN, WAIT_READ, READ_IO };
      multi_seven_seg seg;
      
      dff reg_select[4];
      dff port_select[8];
      

      dff led_waiting_for_io_read[1];
      dff io_read[8];
      
      dff tmp_addr[19];
      dff tmp_d_out[8];

      device_timers rtc;
      device_serial serial;
      
      iobus iobus;
    }
  }
  
  always {
    dbe = io_dip[0][0];
    hideROM = io_dip[0][7];

    /* Clock Wizard Connections */
    clk_wiz.clk_in1 = clk; // 100MHz in
    clk_wiz.reset = !rst_n; // reset signal
    
    /* DDR3 Connections */
    ddr3_addr = mig.ddr3_addr;
    ddr3_ba = mig.ddr3_ba;
    ddr3_ras_n = mig.ddr3_ras_n;
    ddr3_cas_n = mig.ddr3_cas_n;
    ddr3_we_n = mig.ddr3_we_n;
    ddr3_reset_n = mig.ddr3_reset_n;
    ddr3_ck_p = mig.ddr3_ck_p;
    ddr3_ck_n = mig.ddr3_ck_n;
    ddr3_cke = mig.ddr3_cke;
    ddr3_cs_n = mig.ddr3_cs_n;
    ddr3_dm = mig.ddr3_dm;
    ddr3_odt = mig.ddr3_odt;
     
    mig.sys_clk = clk_wiz.clk_out1; // 100MHz clock
    mig.clk_ref = clk_wiz.clk_out2; // 200MHz clock
    mig.sys_rst = !clk_wiz.locked;  // reset when clk_wiz isn't locked
    rst = mig.sync_rst;             // use the reset signal from the mig core
    
    // configure the arbiter 
    mig.mem_in = mem_arbiter.master_in;
    mem_arbiter.master_out = mig.mem_out;
  
    // wire up the LRU cache ; it's at lowest priority to make room for video & other devices
    mem_arbiter.device_in[1] = cache.mem_in;
    cache.mem_out = mem_arbiter.device_out[1];
    
    
    cache.flush = 0; // don't need to flush
    cache.wr_addr = c{9b0, cpu.address};
    cache.wr_data = c{cpu.d_out, 8b0};
    cache.wr_valid = 0;
    cache.rd_addr = c{9b0, cpu.address};
    cache.rd_cmd_valid = 0;
    
    
    /* buttons & edge conditioners */    
    up_button_cond.in = io_button[0];
    up_edge_detector.in = up_button_cond.out;

    down_button_cond.in = io_button[2];
    down_edge_detector.in = down_button_cond.out;

    nmi_button_cond.in = io_button[3];
    nmi_edge_detector.in = nmi_button_cond.out;
        
    //rdy_button_cond.in = io_button[1];
    //rdy_edge_detector.in = rdy_button_cond.out;
    


    // connect USB serial to the serial device
    serial.usb_rx = usb_rx;
    usb_tx = serial.usb_tx;

    // serial device wants access to memory
    mem_arbiter.device_in[0] = serial.mem_in;
    serial.mem_out = mem_arbiter.device_out[0];
    
    // connect the io bus to the CPU and Serial device (this is NOT how we'll want to do it for real)
    iobus.bus_in.read = cpu.io_read | serial.bus_in.read;
    iobus.bus_in.write = cpu.io_write | serial.bus_in.write;
    iobus.bus_in.en = 1;
    iobus.bus_in.wr_data = cpu.io_write ? cpu.io_out : serial.bus_in.write ? serial.bus_in.wr_data : 8bx;
    iobus.bus_in.addr = (cpu.io_read|cpu.io_write) ? cpu.port : (serial.bus_in.read|serial.bus_in.write) ? serial.bus_in.addr : 8bx;
    iobus.bus_in.irq_ack = cpu.irq_ack;
    
    // Connect CPU IO in pins to the bus
    cpu.io_rdy = iobus.bus_out.rd_valid;
    cpu.io_in = iobus.bus_out.rd_data;
    cpu.irq = iobus.bus_out.irq;
    cpu.irq_service = iobus.bus_out.irq_service;
    cpu.io_timeout = iobus.bus_out.timeout;
    
    // serial device wants access to the bus so it can read from & write to other devices
    serial.bus_out = iobus.bus_out;
    
    serial.dbg_reg = cpu.dbg_reg;
    serial.dbg_inst = cpu.dbg_inst;
    serial.dbg_clocks = cpu.dbg_clocks;
    
    // hang devices off the bus
    rtc.device_in = iobus.device_in;
    serial.device_in = iobus.device_in;
    iobus.device_out = rtc.device_out | serial.device_out;

    cpu.ready = 0;
    cpu.dbe = dbe;    
    cpu.d_in = 8hxx;
    cpu.d_rdy = 0;
    cpu.nmi = 0 ;
    cpu.dbg_reg_data = 16bx; //serial.dbg_reg_wr_data;
    cpu.dbg_reg_write = 0; //serial.dbg_reg_write;
    cpu.dbg_reg_sel = 4bx; //serial.dbg_reg_sel;
    if (serial.dbg_reg_write) {
      cpu.dbg_reg_data = serial.dbg_reg_wr_data;
      cpu.dbg_reg_write = 1;
      cpu.dbg_reg_sel = serial.dbg_reg_sel;
    }
        
    if (serial.nmi | nmi_edge_detector.out) {
          cpu.irq_service = 1;    // tell the CPU it's had a trap
          cpu.nmi = 1;            // assert NMI
    }

    led = c{1b0, io_button[0], io_button[1], io_button[2], io_button[3], hideROM, dbe, rst};
    
    rom.addr = cpu.address[15:0]; // rom can be wired up to the lower 16 bits on the address line by default
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    seg.values = {4h0,4h0,4h0,4h0};
    seg.dots = 4h0;
    io_seg = ~seg.seg;           // connect segments to the driver
    io_sel = ~seg.sel;           // connect digit select to the driver

    frontSel = io_dip[2][7:6];

    case (frontSel) {
      2b00:
        if (up_edge_detector.out) reg_select.d = reg_select.q + 1; // we have additional debug information past reg 12, so we can fake 16 registers   
        if (down_edge_detector.out) reg_select.d = reg_select.q - 1;
        
        // show memory address on LEDs
        io_led = {c{cache.rd_ready, cache.rd_data_valid, cache.wr_ready, iobus.bus_out.rdy, iobus.bus_out.irq_service, 
                    cpu.address[18:16]}, cpu.address[15:8], cpu.address[7:0]};
        
        case (reg_select.q) {
          4hC: seg.values = {cpu.dbg_clocks[31:28], cpu.dbg_clocks[27:24], cpu.dbg_clocks[23:20], cpu.dbg_clocks[19:16]};
          4hD: seg.values = {cpu.dbg_clocks[15:12], cpu.dbg_clocks[11:8] , cpu.dbg_clocks[7:4],   cpu.dbg_clocks[3:0]};
          4hE: seg.values = {cpu.dbg_inst[31:28], cpu.dbg_inst[27:24], cpu.dbg_inst[23:20], cpu.dbg_inst[19:16]};
          4hF: seg.values = {cpu.dbg_inst[15:12], cpu.dbg_inst[11:8], cpu.dbg_inst[7:4], cpu.dbg_inst[3:0]};
          default:
            seg.values = {cpu.dbg_reg[reg_select.q][15:12], cpu.dbg_reg[reg_select.q][11:8], 
                          cpu.dbg_reg[reg_select.q][7:4], cpu.dbg_reg[reg_select.q][3:0]}; // show selected register on IO 7Seg
        }
        seg.dots = reg_select.q;     // dots represent selected register for debugging
      2b10:
        if (up_edge_detector.out) {
          port_select.d = port_select.q + 1; 
          io_read.d = port_select.q;
        }
        if (down_edge_detector.out) {
          port_select.d = port_select.q - 1;
          io_read.d = port_select.q;
        }
        // show memory address on LEDs
        io_led = {c{cache.rd_ready, cache.rd_data_valid, cache.wr_ready, iobus.bus_out.rdy, iobus.bus_out.irq_service, 
                    cpu.address[18:16]}, cpu.address[15:8], cpu.address[7:0]};
        if (iobus.bus_out.rdy) {
          iobus.bus_in.addr = port_select.q;
          led_waiting_for_io_read.d = 1;
          iobus.bus_in.read = 1;
          if (iobus.bus_out.rd_valid) {
            io_read.d = iobus.bus_out.rd_data;
            led_waiting_for_io_read.d = 0;
          }
        }
        if (led_waiting_for_io_read.q) {
          iobus.bus_in.addr = port_select.q;
          if (iobus.bus_out.rd_valid) {
            io_read.d = iobus.bus_out.rd_data;
            led_waiting_for_io_read.d = 0;
          }
        }
        seg.values = {port_select.q[7:4], port_select.q[3:0], io_read.q[7:4], io_read.q[3:0]}; // show selected register on IO 7Seg      
    }
    
    case (state.q) {
      state.RUN_CPU:
        cpu.ready = 1;
        if (cpu.d_read) {                    // CPU is requesting to read data from memory;
          if (&cpu.address[18:16] && !hideROM) {  // if the address is in bank 7 (111_xxxxxxxx_xxxxxxxx)
            cpu.d_in = rom.out;              // get the byte from ROM and give it to the CPU
            cpu.d_rdy = 1;                   // signal the CPU that it has data
          } else {
            if (cache.rd_ready) {            // otherwise it's asking to read from RAM... but that takes time
              cache.rd_cmd_valid = 1;        // ... ask cache to read from address
              state.d = state.WAIT_MEM_READ; // ... and wait
            }
            if (cache.rd_data_valid) {           // If data is available
              cpu.ready = 1;                     // ... CPU can run 
              cpu.d_in = cache.rd_data[15:8];          // ... send the data in
              cpu.d_rdy = 1;                     // ... and notify CPU
            }
          }
        }
        if (cpu.d_write) {                   // requesting to write to memory
          if (cpu.address[18:16] != 3h7) {
            if (cache.wr_ready) {              // ... can we write to memory? 
              cache.wr_valid = 1;              // ... notify cache to write the data
              state.d = state.MEM_FLUSH_CACHE; // ... flush cache
            } else {
              tmp_d_out.d = cpu.d_out;
              tmp_addr.d = cpu.address;
              state.d = state.WAIT_MEM_WRITE;  // ... wait until we can written
            }
          }
        }
        
        if (cpu.io_read) {
          state.d = state.WAIT_IO_READ_RDY;
        }
        if (cpu.io_write) {
          tmp_d_out.d = c{8b0,cpu.io_out};
          state.d = state.WAIT_IO_WRITE_RDY;
        }
      state.WAIT_MEM_READ:                   // Waiting for data from RAM
        if (cache.rd_data_valid) {           // If data is available
          cpu.ready = 1;                     // ... CPU can run 
          cpu.d_in = cache.rd_data[15:8];          // ... send the data in
          cpu.d_rdy = 1;                     // ... and notify CPU
          state.d = state.RUN_CPU;           // ... move back to RUN CPU
        }
      state.WAIT_MEM_WRITE:                // don't run CPU
        if (cache.wr_ready) {              // ... can we write to memory? 
          cache.wr_data = c{tmp_d_out.q, 8b0};
          cache.wr_addr = tmp_addr.q;
          cache.wr_valid = 1;              // ... notify cache to write the data
          state.d = state.MEM_FLUSH_CACHE; 
        }
      state.MEM_FLUSH_CACHE:
        // wait until the data is actually written, then flush.
        if (cache.wr_ready && cache.flush_ready) {
          cache.flush = 1;
          state.d = state.RUN_CPU;
        }
      state.WAIT_IO_READ_RDY:
        if (iobus.bus_out.rdy) {
            iobus.bus_in.read = 1;
            state.d = state.WAIT_IO_READ;
        }
        if (iobus.bus_out.rd_valid) {                  // wait until we get data back from device
          cpu.ready = 1;                     // ... CPU can run
          //cpu.io_rdy = 1;                    // ... notify CPU that IO data is valid (it's already wired up)
          state.d = state.RUN_CPU;           // ... move back to RUN CPU
        }
      state.WAIT_IO_READ:
        if (iobus.bus_out.rd_valid) {                  // wait until we get data back from device
          cpu.ready = 1;                     // ... CPU can run
          //cpu.io_rdy = 1;                    // ... notify CPU that IO data is valid (it's already wired up)
          state.d = state.RUN_CPU;           // ... move back to RUN CPU
        }
      state.WAIT_IO_WRITE_RDY:
        if (iobus.bus_out.rdy) {
          iobus.bus_in.wr_data = tmp_d_out.q[7:0];
          iobus.bus_in.write = 1;
          cpu.ready = 1;
          state.d = state.RUN_CPU;
        }
    }
    
  }
}