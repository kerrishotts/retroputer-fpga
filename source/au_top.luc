module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    /* DDR3 Connections */
    inout ddr3_dq[16],
    inout ddr3_dqs_n[2],
    inout ddr3_dqs_p[2],
    output ddr3_addr[14],
    output ddr3_ba[3],
    output ddr3_ras_n,
    output ddr3_cas_n,
    output ddr3_we_n,
    output ddr3_reset_n,
    output ddr3_ck_p,
    output ddr3_ck_n,
    output ddr3_cke,
    output ddr3_cs_n,
    output ddr3_dm[2],
    output ddr3_odt,
    /* IO board */
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal
  
  clk_wiz_0 clk_wiz;

  
  // DDR3 Interface - connect inouts directly
  mig_wrapper mig (.ddr3_dq(ddr3_dq), .ddr3_dqs_n(ddr3_dqs_n), .ddr3_dqs_p(ddr3_dqs_p) );
  
  .clk(mig.ui_clk) {
    //edge_detector rdy_edge_detector(#RISE(1), #FALL(0)); // detect rising edges
    //button_conditioner rdy_button_cond;     // button input conditioner

    edge_detector nmi_edge_detector(#RISE(1), #FALL(0)); // detect rising edges
    button_conditioner nmi_button_cond;     // button input conditioner

    edge_detector up_edge_detector(#RISE(1), #FALL(0)); // detect rising edges
    button_conditioner up_button_cond;     // button input conditioner

    edge_detector down_edge_detector(#RISE(1), #FALL(0)); // detect rising edges
    button_conditioner down_button_cond;     // button input conditioner
        
    .rst(rst) {
      cpu cpu;
      lru_cache cache(#ENTRIES(1), #WORD_SIZE(8), #AGE_BITS(1));
      fsm state = { RUN_CPU, WAIT_READ };
      multi_seven_seg seg;
      
      dff reg_select[4];
    }
  }
  
  always {
  /* Clock Wizard Connections */
    clk_wiz.clk_in1 = clk; // 100MHz in
    clk_wiz.reset = !rst_n; // reset signal
    
  /* DDR3 Connections */
    ddr3_addr = mig.ddr3_addr;
    ddr3_ba = mig.ddr3_ba;
    ddr3_ras_n = mig.ddr3_ras_n;
    ddr3_cas_n = mig.ddr3_cas_n;
    ddr3_we_n = mig.ddr3_we_n;
    ddr3_reset_n = mig.ddr3_reset_n;
    ddr3_ck_p = mig.ddr3_ck_p;
    ddr3_ck_n = mig.ddr3_ck_n;
    ddr3_cke = mig.ddr3_cke;
    ddr3_cs_n = mig.ddr3_cs_n;
    ddr3_dm = mig.ddr3_dm;
    ddr3_odt = mig.ddr3_odt;
     
    mig.sys_clk = clk_wiz.clk_out1; // 100MHz clock
    mig.clk_ref = clk_wiz.clk_out2; // 200MHz clock
    mig.sys_rst = !clk_wiz.locked;  // reset when clk_wiz isn't locked
    rst = mig.sync_rst;             // use the reset signal from the mig core
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits

    usb_tx = usb_rx;        // echo the serial data
    
    mig.mem_in = cache.mem_in;
    cache.mem_out = mig.mem_out;
    
    cache.flush = 0; // don't need to flush
    cache.wr_addr = cpu.address;
    cache.wr_data = cpu.d_out;
    cache.wr_valid = 0;
    cache.rd_addr = cpu.address;
    cache.rd_cmd_valid = 0;
    
    up_button_cond.in = io_button[0];
    up_edge_detector.in = up_button_cond.out;

    down_button_cond.in = io_button[2];
    down_edge_detector.in = down_button_cond.out;
    if (up_edge_detector.out) {
        reg_select.d = reg_select.q == 11 ? 0 : reg_select.q + 1; // wrap back to zero after 12 registers
        
    }
    if (down_edge_detector.out) {
        reg_select.d = reg_select.q == 0 ? 11 : reg_select.q - 1; // wrap back to 11 after going past first register
    }

    nmi_button_cond.in = io_button[3];
    nmi_edge_detector.in = nmi_button_cond.out;
        
    //rdy_button_cond.in = io_button[1];
    //rdy_edge_detector.in = rdy_button_cond.out;
    
    led = c{2h00, io_button[0], io_button[1], io_button[2], io_button[3], io_dip[0][0], rst};
    
    cpu.trap = 0;
    cpu.ready = 0;
    cpu.dbe = io_dip[0][0];     // DEBUG ENABLED is DIP SWITCH 0
    cpu.irq = 0;
    cpu.io_in = 8hxx;
    cpu.d_in = 8hxx;
    cpu.d_rdy = 0;
    cpu.io_rdy = 0;
    
    cpu.dbg_reg_sel = reg_select.q;
    // show memory address on LEDs
    io_led = {c{cache.rd_ready, cache.rd_data_valid, cache.wr_ready, 2b0, cpu.address[18:16]}, cpu.address[15:8], cpu.address[7:0]};
    
    seg.values = {cpu.dbg_reg_val[15:12], cpu.dbg_reg_val[11:8], cpu.dbg_reg_val[7:4], cpu.dbg_reg_val[3:0]}; // show selected register on IO 7Seg
    seg.dots = reg_select.q;     // dots represent selected register for debugging
    io_seg = ~seg.seg;           // connect segments to the driver
    io_sel = ~seg.sel;           // connect digit select to the driver
    
    if (nmi_edge_detector.out) { // user pressed NMI button
      cpu.trap = 1;              // tell the CPU it's had a trap
      cpu.irq = 8hff;            // assert NMI, trap 127
    }
    
    case (state.q) {
      state.RUN_CPU:
        cpu.ready = 1;
        if (cpu.d_read) {
          if (cache.rd_ready) {
            cache.rd_cmd_valid = 1;
            state.d = state.WAIT_READ;
          }
        }
        if (cpu.d_write) {
          if (cache.wr_ready) {
            cache.wr_valid = 1;
          }
        }
      state.WAIT_READ:
        if (cache.rd_data_valid) {
          cpu.ready = 1;
          cpu.d_in = cache.rd_data;
          cpu.d_rdy = 1;
          state.d = state.RUN_CPU;
        }
    }

  }
}