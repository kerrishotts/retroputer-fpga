module memory_controller (
    input clk,  // clock
    input rst,  // reset
    
    input rom_en,           // if ROM is enabled, route read requests to RAM
    input shadow_wr_en,     // if shadow write enable is set, we can write to the RAM behind the ROM

    output busy,            // feed to READY or ENABLE to other devices to pause them as needed
    input address[19],      // address (for both read & write)
    input d_read,           // read request
    input d_write,          // write request
    input d_in[8],          // data in (for write)
    output d_rdy,           // signals when data is ready (after READ)
    output d_out[8],        // data out (for reads)
    
    
    /* system ram */
    output sram_rd_addr[19],
    output sram_rd_cmd_valid,
    input  sram_rd_ready,
    input  sram_rd_data[8],
    input  sram_rd_data_valid,
    
    output sram_wr_addr[19],
    output sram_wr_data[8],
    output sram_wr_valid,
    input  sram_wr_ready,
    
    /* system rom */
    
    output srom_addr[16],
    input  srom_data[8]
    
  ) {

  .clk(clk), .rst(rst) {
    fsm state = { IDLE, READ, WRITE };
    dff latch_address[19];
    dff latch_d_in[8];
    dff rom_read_rdy[2];
  }
  
  sig read_rom;
  
  always {
    busy = state.q == state.IDLE;
    
    read_rom = &latch_address.q[18:16] && rom_en;
    
    d_rdy = 0;
    d_out = 8bx;
    sram_rd_addr = 19bx;
    sram_rd_cmd_valid = 0;
    sram_wr_addr = 19bx;
    sram_wr_data = 8bx;
    sram_wr_valid = 0;
    srom_addr = 16bx;
    
    case(state.q) {
      state.IDLE:
        latch_address.d = address;
        latch_d_in.d = d_in;
        if (d_read) state.d = state.READ;
        if (d_write) {
          state.d = state.WRITE;
          if (&address[18:16] && !shadow_wr_en) state.d = state.IDLE; /* writing to shadow RAM disabled */
        }
      state.READ:
        case(read_rom) {
          1b1: // read from ROM
            srom_addr = latch_address.q[15:0];
            rom_read_rdy.d = rom_read_rdy.q+1;  // ROM is readable after 1 clock; so toggle the read readiness (we start with NOT ready)
            if (rom_read_rdy.q[1]) {
              busy  = 0;
              d_out = srom_data;
              d_rdy = 1;
              state.d = state.IDLE;
              rom_read_rdy.d = 0;
            }
          1b0: // read from RAM
            if (sram_rd_ready) {
              sram_rd_cmd_valid = 1;
              sram_rd_addr = latch_address.q;
            }
            if (sram_rd_data_valid) {
              busy  = 0;
              d_out = sram_rd_data;
              d_rdy = 1;
              state.d = state.IDLE;
            }
        }
      state.WRITE:
        if (sram_wr_ready) {
          sram_wr_addr = latch_address.q;
          sram_wr_data = latch_d_in.q;
          sram_wr_valid = 1;
          state.d = state.IDLE;
        }
    }
  }
}
